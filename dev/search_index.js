var documenterSearchIndex = {"docs":
[{"location":"#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"#API-Reference","page":"Manual","title":"API Reference","text":"","category":"section"},{"location":"#Quickhull.quickhull","page":"Manual","title":"Quickhull.quickhull","text":"quickhull(points, options=Quickhull.Options())\n\nCompute the convex hull of points. points can be a vector of point-like objects (e.g. Tuple or StaticVector) or a (D, N)-sized matrix of numbers.\n\nSee documentation for Quickhull.Options. Note options is a positional argument, not a keyword argument: quickhull(points, Quickhull.Options(...)) is the correct calling syntax.\n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.delaunay","page":"Manual","title":"Quickhull.delaunay","text":"delaunay(points, options=Quickhull.Options())\n\nCompute the d-dimensional Delaunay triangulation of points. points can be a vector of point-like objects (e.g. Tuple or StaticVector) or a (D, N)-sized matrix of numbers.\n\nThe triangulation is found by lifting into d+1 dimensions and taking the convex hull.\n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.Options","page":"Manual","title":"Quickhull.Options","text":"Quickhull.Options(options...)\n\nAvaliable options are:\n\nkernel – a subtype of HyperplaneKernel used for hyperplane calculations. HyperplaneKernelExactSIMD by default.\nindextype – a subtype of Integer that specifies how vertex indices should be stored. Int32 by default.\njoggle – whether to joggle the input points. false by default\njoggle_amount – how much to joggle the input points. 100.0 by default.\nstatistics – whether to record statistics. false by default.\nsubdivide – controls whether hull is computed by subdividing the input points and merging the resulting sub-hulls. Available options are:\nNoSubdivide() – don't use subdivision (default).\nSerialSubdivide(chunks=nchunks, levels=nlevels) – subdivide points into nchunks many chunks, nlevels many times recursively. Not parallel.\nParallelSubdivide(chunks=nchunks, levels=nlevels) – subdivide points into nchunks many chunks, nlevels many times recursively. Sub-hulls are computed in parallel.\n\n\n\n\n\n","category":"type"},{"location":"#Quickhull.points-Tuple{Quickhull.AbstractHull}","page":"Manual","title":"Quickhull.points","text":"points(hull)\n\nThe points the hull was constructed from. This includes points inside the hull - see vertices(hull) and vertexpoints(hull).\n\n\n\n\n\n","category":"method"},{"location":"#Quickhull.vertices-Tuple{Quickhull.AbstractHull}","page":"Manual","title":"Quickhull.vertices","text":"vertices(hull)\n\nThe indices of points that are vertices of the hull.\n\n\n\n\n\n","category":"method"},{"location":"#Quickhull.facets-Tuple{Quickhull.AbstractHull}","page":"Manual","title":"Quickhull.facets","text":"facets(hull)\n\nThe facets of the hull. A facet is defined by D vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{Any, Quickhull.Hull}","page":"Manual","title":"Base.in","text":"in(pt, hull)\n\nDetermine if a point is inside (or on the boundary) of the hull.\n\n\n\n\n\n","category":"method"},{"location":"#Base.insert!-Tuple{Quickhull.Hull, Any}","page":"Manual","title":"Base.insert!","text":"insert!(hull, pt)\n\nInsert a new point into the hull. Returns true if the point wasn't already in the hull.\n\nRequires the hull to have been created from a vector of points that supports push! (e.g. this won't work if a matrix of points was used). Performance is O(f) in the number of hull facets, so it may faster to rebuild the hull than to insert many points.\n\n\n\n\n\n","category":"method"},{"location":"#GeometryBasics.Mesh-Tuple{Quickhull.AbstractHull}","page":"Manual","title":"GeometryBasics.Mesh","text":"GeometryBasics.Mesh(hull::Quickhull.AbstractHull)\n\nCreate a Mesh from the points and facets of hull.\n\n\n\n\n\n","category":"method"},{"location":"#Voronoi-Utilities","page":"Manual","title":"Voronoi Utilities","text":"","category":"section"},{"location":"#Quickhull.voronoi_centers","page":"Manual","title":"Quickhull.voronoi_centers","text":"voronoi_centers(delaunay_hull)\n\nThe circumcenters of a Delaunay triangulation's faces.\n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.voronoi_edges","page":"Manual","title":"Quickhull.voronoi_edges","text":"voronoi_edges(delaunay_hull)\n\nReturn a vector of edges that form the Voronoi diagram (excluding rays). Each edge is a tuple (v1, v2) of point indices into voronoi_centers(delaunay_hull). \n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.voronoi_edge_points","page":"Manual","title":"Quickhull.voronoi_edge_points","text":"voronoi_edges_points(delaunay_hull)\n\nReturn a vector of edges that form the Voronoi diagram (excluding rays). Each edge is a tuple (p1, p2) of line segment endpoints.\n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.voronoi_edge_points_homogeneous","page":"Manual","title":"Quickhull.voronoi_edge_points_homogeneous","text":"voronoi_edge_points_homogeneous(delaunay_hull)\n\nReturn a vector of edges that form the Voronoi diagram (including rays). Each edge is a tuple (p1, p2) of line segment endpoints in homogeneous coordinates. This means an extra coordinate has been added to the end of each point: if the coordinate is 1 the point is a 'normal' point, and if the coordinate is 0 the point is 'at infinity'.\n\n\n\n\n\n","category":"function"},{"location":"#Quickhull.voronoi_edge_points_projected","page":"Manual","title":"Quickhull.voronoi_edge_points_projected","text":"voronoi_edge_points_projected(delaunay_hull, raylength=1)\n\nReturn a vector of edges that form the Voronoi diagram (including rays). Each edge is a tuple (p1, p2) of line segment endpoints. Rays are projected out to be length raylength.\n\n\n\n\n\n","category":"function"},{"location":"#Extensions","page":"Manual","title":"Extensions","text":"","category":"section"},{"location":"#Quickhull.PolyhedraLibrary","page":"Manual","title":"Quickhull.PolyhedraLibrary","text":"PolyhedraLibrary(solver)\n\nCreate an instance of a Polyhedra.Library with the given solver that uses quickhull as a backend. Requires the Polyhedra package to be loaded.\n\n\n\n\n\n","category":"function"}]
}
